# GitHub ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è­¦å‘Š80 ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆé©ç”¨åˆ†æãƒ¬ãƒãƒ¼ãƒˆ

**ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ**: XBRL Financial Data API - Minimal Edition
**åˆ†ææ—¥æ™‚**: 2025å¹´9æœˆ19æ—¥
**ãƒ¬ãƒãƒ¼ãƒˆç¨®åˆ¥**: æ©Ÿå¯†æƒ…å ±å¹³æ–‡ä¿å­˜è„†å¼±æ€§åˆ†æã¨å®Ÿè£…è¨ˆç”»
**é‡è¦åº¦**: ğŸš¨ HIGH

---

## ğŸ“‹ ã‚¨ã‚°ã‚¼ã‚¯ãƒ†ã‚£ãƒ–ã‚µãƒãƒªãƒ¼

### ğŸ¯ **åˆ†ææ¦‚è¦**
GitHub ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è­¦å‘Š #80 ã¯ã€CodeQLã«ã‚ˆã£ã¦æ¤œå‡ºã•ã‚Œã‚‹ã€ŒClear text storage of sensitive informationã€ï¼ˆæ©Ÿå¯†æƒ…å ±ã®å¹³æ–‡ä¿å­˜ï¼‰è„†å¼±æ€§ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æŒ‡ã—ã¦ã„ã¾ã™ã€‚XBRLãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ãŠã„ã¦ã€APIã‚­ãƒ¼ã€èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šæƒ…å ±ãªã©ã®æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ãŒæš—å·åŒ–ã•ã‚Œãšã«ä¿å­˜ãƒ»å‡¦ç†ã•ã‚Œã¦ãŠã‚Šã€ãƒ‡ãƒ¼ã‚¿æ¼æ´©æ™‚ã«æ·±åˆ»ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯ã‚’æŠ±ãˆã¦ã„ã¾ã™ã€‚

### âš ï¸ **ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«è©•ä¾¡**
```yaml
ç·åˆãƒªã‚¹ã‚¯: ğŸ”´ HIGH (8.2/10)
ç·Šæ€¥åº¦: HIGH
å½±éŸ¿ç¯„å›²: æ©Ÿå¯†æƒ…å ±ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“
å¯¾å¿œæœŸé™: å³åº§ï¼ˆ24-48æ™‚é–“ä»¥å†…ï¼‰
```

### ğŸ¯ **ä¸»è¦æ¨å¥¨äº‹é …**
1. **æ©Ÿå¯†æƒ…å ±æš—å·åŒ–ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…**
2. **ç’°å¢ƒå¤‰æ•°ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®å¼·åŒ–**
3. **APIã‚­ãƒ¼ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®æ”¹å–„**
4. **åŒ…æ‹¬çš„ãªæ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ä¿è­·ã®å®Ÿè£…**

---

## ğŸš¨ ç‰¹å®šã•ã‚ŒãŸè„†å¼±æ€§è©³ç´°

### **CWE-312: Clear Text Storage of Sensitive Information**

#### **æŠ€è¡“çš„æ¦‚è¦**
- **è„†å¼±æ€§ç¨®åˆ¥**: Clear text storage of sensitive information
- **CVSS Score**: 8.2 (High)
- **å½±éŸ¿ç¯„å›²**: èªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã€APIã‚­ãƒ¼ç®¡ç†ã€è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«
- **æ”»æ’ƒãƒ™ã‚¯ã‚¿ãƒ¼**: ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚¢ã‚¯ã‚»ã‚¹ã€ãƒ¡ãƒ¢ãƒªãƒ€ãƒ³ãƒ—ã€ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«

#### **æ”»æ’ƒãƒ¡ã‚«ãƒ‹ã‚ºãƒ **
```bash
# æ”»æ’ƒä¾‹1: ç’°å¢ƒå¤‰æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ä¸æ­£ã‚¢ã‚¯ã‚»ã‚¹
cat .env.local
# SUPABASE_SERVICE_ROLE_KEY=eyJ...ï¼ˆå¹³æ–‡ã§æ©Ÿå¯†æƒ…å ±ãŒæ¼æ´©ï¼‰

# æ”»æ’ƒä¾‹2: ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ­ã‚°ã‹ã‚‰ã®æƒ…å ±çªƒå–
grep -r "supabase" /var/log/
# APIã‚­ãƒ¼ã‚„ãƒˆãƒ¼ã‚¯ãƒ³ãŒãƒ­ã‚°ã«å¹³æ–‡ã§è¨˜éŒ²

# æ”»æ’ƒä¾‹3: ãƒ¡ãƒ¢ãƒªãƒ€ãƒ³ãƒ—è§£æ
gdb -p $(pgrep node)
# ãƒ¡ãƒ¢ãƒªå†…ã®å¹³æ–‡APIã‚­ãƒ¼ã‚’ç›´æ¥æŠ½å‡º

# æ”»æ’ƒä¾‹4: ãƒ–ãƒ©ã‚¦ã‚¶é–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«ã§ã®æƒ…å ±çªƒå–
localStorage.getItem('auth-token')  // å¹³æ–‡ã§ä¿å­˜ã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³
```

#### **ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å…·ä½“çš„å½±éŸ¿**
```typescript
// è„†å¼±ãªå®Ÿè£…ä¾‹ (ç’°å¢ƒå¤‰æ•°ã®å¹³æ–‡ä¿å­˜)
// .env.local
SUPABASE_SERVICE_ROLE_KEY=eyJhbGciOiJIUzI1NiIs...  // âŒ å¹³æ–‡ä¿å­˜

// è„†å¼±ãªå®Ÿè£…ä¾‹ (APIã‚­ãƒ¼ã®å¹³æ–‡è¡¨ç¤º)
// app/welcome/page.tsx:132
userData.apiKey ? userData.apiKey : // âŒ å¹³æ–‡ã§APIã‚­ãƒ¼è¡¨ç¤º

// è„†å¼±ãªå®Ÿè£…ä¾‹ (è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ã®æ©Ÿå¯†æƒ…å ±)
// infrastructure/deploy/production.config.ts:88
serviceRoleKey: process.env.SUPABASE_SERVICE_ROLE_KEY, // âŒ ç›´æ¥å‚ç…§

// è„†å¼±ãªå®Ÿè£…ä¾‹ (ãƒ­ã‚°å‡ºåŠ›ã§ã®æƒ…å ±æ¼æ´©)
// supabase/functions/_shared/utils.ts:165
console.log("[DEBUG] Starting O(1) API key verification for key:",
  key ? `${key.substring(0, 15)}...` : 'null');  // âŒ ãƒ­ã‚°ã§APIã‚­ãƒ¼éƒ¨åˆ†æš´éœ²
```

#### **å®Ÿéš›ã®ãƒªã‚¹ã‚¯ã‚·ãƒŠãƒªã‚ª**
```yaml
ã‚·ãƒŠãƒªã‚ª1: é–‹ç™ºç’°å¢ƒã‹ã‚‰ã®æƒ…å ±æ¼æ´©
  1. é–‹ç™ºè€…ã®ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã«ä¸æ­£ã‚¢ã‚¯ã‚»ã‚¹
  2. .env.localãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å¹³æ–‡ã®æ©Ÿå¯†æƒ…å ±ã‚’çªƒå–
  3. Supabaseã‚µãƒ¼ãƒ“ã‚¹ãƒ­ãƒ¼ãƒ«ã‚­ãƒ¼ã§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å…¨ä½“ã«ã‚¢ã‚¯ã‚»ã‚¹
  4. 4,231ç¤¾ã®ä¼æ¥­è²¡å‹™ãƒ‡ãƒ¼ã‚¿ã‚’å®Œå…¨ã«çªƒå–

ã‚·ãƒŠãƒªã‚ª2: ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«çµŒç”±ã®æƒ…å ±æ¼æ´©
  1. ã‚µãƒ¼ãƒãƒ¼ãƒ­ã‚°ã¸ã®ä¸æ­£ã‚¢ã‚¯ã‚»ã‚¹
  2. ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã‹ã‚‰APIã‚­ãƒ¼æƒ…å ±ã‚’æŠ½å‡º
  3. æŠ½å‡ºã—ãŸæƒ…å ±ã§èªè¨¼ã‚’å›é¿
  4. è²¡å‹™ãƒ‡ãƒ¼ã‚¿APIã¸ã®å®Œå…¨ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ã‚’ç²å¾—

ã‚·ãƒŠãƒªã‚ª3: ãƒ–ãƒ©ã‚¦ã‚¶çµŒç”±ã®æƒ…å ±æ¼æ´©
  1. XSSæ”»æ’ƒã¾ãŸã¯ãƒ–ãƒ©ã‚¦ã‚¶æ‹¡å¼µæ©Ÿèƒ½ã®æ‚ªç”¨
  2. localStorage/sessionStorageã‹ã‚‰å¹³æ–‡ãƒˆãƒ¼ã‚¯ãƒ³ã‚’çªƒå–
  3. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’å®Œå…¨ã«ä¹—ã£å–ã‚Š
  4. ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰æ©Ÿèƒ½ã‚’å®Œå…¨ã«æ‚ªç”¨

ã‚·ãƒŠãƒªã‚ª4: ãƒ¡ãƒ¢ãƒªãƒ€ãƒ³ãƒ—æ”»æ’ƒ
  1. ã‚·ã‚¹ãƒ†ãƒ ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã¾ãŸã¯å¼·åˆ¶ãƒ¡ãƒ¢ãƒªãƒ€ãƒ³ãƒ—
  2. ãƒ—ãƒ­ã‚»ã‚¹ãƒ¡ãƒ¢ãƒªã‹ã‚‰å¹³æ–‡æ©Ÿå¯†æƒ…å ±ã‚’è§£æ
  3. å®Ÿè¡Œæ™‚ã«å‡¦ç†ã•ã‚Œã‚‹APIã‚­ãƒ¼ã‚„ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æŠ½å‡º
  4. é•·æœŸé–“ã®ä¸æ­£ã‚¢ã‚¯ã‚»ã‚¹ã‚’ç¶™ç¶š
```

---

## ğŸ” ç¾åœ¨ã®ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹è„†å¼±æ€§åˆ†æ

### **ç‰¹å®šã•ã‚ŒãŸè„†å¼±ãªç®‡æ‰€**

#### **1. ç’°å¢ƒå¤‰æ•°ã§ã®å¹³æ–‡ä¿å­˜**
```bash
# .env.example - è¨­å®šä¾‹ã§ã®å•é¡Œ
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key  # âŒ å¹³æ–‡ä¿å­˜æŒ‡ç¤º
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key      # âŒ ãƒ‘ãƒ–ãƒªãƒƒã‚¯æš´éœ²

# å®Ÿéš›ã®.env.localã§ã‚‚åŒæ§˜ã®å¹³æ–‡ä¿å­˜ãŒç™ºç”Ÿ
```

#### **2. APIã‚­ãƒ¼å¹³æ–‡è¡¨ç¤ºãƒ»å‡¦ç†**
```typescript
// app/welcome/page.tsx (L132)
value={userData.apiKey ? userData.apiKey :        // âŒ å¹³æ–‡API keyè¡¨ç¤º
      isGeneratingKey ? 'APIã‚­ãƒ¼ã‚’ç”Ÿæˆä¸­...' :
      apiKeyError ? 'ã‚¨ãƒ©ãƒ¼: APIã‚­ãƒ¼ç”Ÿæˆå¤±æ•—' :
      'APIã‚­ãƒ¼æœªç”Ÿæˆ'}

// components/ApiKeyDisplay.tsx (L43)
await navigator.clipboard.writeText(apiKey);     // âŒ å¹³æ–‡ã§ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼

// app/welcome/page.tsx (L248)
curl -H "X-API-Key: ${userData.apiKey || 'YOUR_API_KEY'}" // âŒ å¹³æ–‡ã§ã‚³ãƒ¼ãƒ‰ä¾‹è¡¨ç¤º
```

#### **3. ãƒ­ã‚°å‡ºåŠ›ã§ã®æƒ…å ±æ¼æ´©**
```typescript
// supabase/functions/_shared/utils.ts (L165)
console.log("[DEBUG] Starting O(1) API key verification for key:",
  key ? `${key.substring(0, 15)}...` : 'null');  // âŒ APIã‚­ãƒ¼å…ˆé ­15æ–‡å­—ã‚’ãƒ­ã‚°å‡ºåŠ›

// supabase/functions/_shared/utils.ts (L175-181)
console.error("API key verification error:", verifyError);  // âŒ ã‚¨ãƒ©ãƒ¼è©³ç´°ã‚’ãƒ­ã‚°å‡ºåŠ›
console.log("[DEBUG] API key validation failed:", verifyResult);  // âŒ æ¤œè¨¼è©³ç´°ãƒ­ã‚°
```

#### **4. è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ã®æ©Ÿå¯†æƒ…å ±å‡¦ç†**
```typescript
// infrastructure/deploy/production.config.ts (L87-88)
anonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,        // âŒ ç›´æ¥å‚ç…§
serviceRoleKey: process.env.SUPABASE_SERVICE_ROLE_KEY,      // âŒ å¹³æ–‡ä¿å­˜ãƒ»å‚ç…§

// app/auth/callback/route.ts (L11-12)
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL     // âŒ è¨­å®šæ¤œè¨¼ãªã—
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY  // âŒ ç›´æ¥ä½¿ç”¨
```

#### **5. ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰æ©Ÿå¯†æƒ…å ±å‡¦ç†**
```typescript
// app/dashboard/AccountSettings.tsx
// APIã‚­ãƒ¼ç®¡ç†ã§å¹³æ–‡ã§ã®è¡¨ç¤ºãƒ»å‡¦ç†ãŒå¤šç”¨ã•ã‚Œã¦ã„ã‚‹

// app/actions/auth.ts (L158)
apiKey: fullApiKey // Return the API key once for the user to save
// âŒ å¹³æ–‡ã§APIã‚­ãƒ¼ã‚’è¿”å´
```

### **ãƒªã‚¹ã‚¯ã‚¢ã‚»ã‚¹ãƒ¡ãƒ³ãƒˆè©³ç´°**
```yaml
æ©Ÿå¯†æƒ…å ±æ¼æ´©ãƒªã‚¹ã‚¯åˆ†æ:
  Supabase Service Role Key: CRITICAL
    - å…¨ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™
    - RLSï¼ˆRow Level Securityï¼‰å®Œå…¨ãƒã‚¤ãƒ‘ã‚¹
    - 4,231ç¤¾ä¼æ¥­ãƒ‡ãƒ¼ã‚¿ã¸ã®ç„¡åˆ¶é™ã‚¢ã‚¯ã‚»ã‚¹

  APIã‚­ãƒ¼æƒ…å ±: HIGH
    - ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®ä¸æ­£ä½¿ç”¨
    - ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã®å›é¿
    - ã‚µãƒ¼ãƒ“ã‚¹åˆ©ç”¨æ–™é‡‘ã®ä¸æ­£ç™ºç”Ÿ

  èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³: HIGH
    - ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚»ãƒƒã‚·ãƒ§ãƒ³ä¹—ã£å–ã‚Š
    - ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰æ©Ÿèƒ½ã®å®Œå…¨æ‚ªç”¨
    - å€‹äººæƒ…å ±ãƒ»ä¼æ¥­æƒ…å ±ã®çªƒå–

æ”»æ’ƒå®Ÿç¾å¯èƒ½æ€§:
  æŠ€è¡“çš„é›£æ˜“åº¦: LOWï¼ˆç°¡å˜ï¼‰
  å¿…è¦ãªæ¨©é™: ä½ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿å–ã‚Šã®ã¿ï¼‰
  æ¤œå‡ºé›£æ˜“åº¦: MEDIUM
  å½±éŸ¿ç¶™ç¶šæœŸé–“: LONGï¼ˆã‚­ãƒ¼æ›´æ–°ã¾ã§ï¼‰
```

---

## ğŸ›¡ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å®Ÿè£…è¨ˆç”»

### **Phase 1: ç·Šæ€¥ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¿®æ­£ï¼ˆ24-48æ™‚é–“ï¼‰**

#### **1.1 æ©Ÿå¯†æƒ…å ±æš—å·åŒ–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å®Ÿè£…**
```typescript
// lib/security/encryption-manager.ts
import crypto from 'crypto'

export class EncryptionManager {
  private static readonly ALGORITHM = 'aes-256-gcm'
  private static readonly KEY_LENGTH = 32
  private static readonly IV_LENGTH = 12
  private static readonly TAG_LENGTH = 16

  // ãƒã‚¹ã‚¿ãƒ¼ã‚­ãƒ¼ã®å–å¾—ï¼ˆç’°å¢ƒå¤‰æ•°ã‹ã‚‰å®‰å…¨ã«å–å¾—ï¼‰
  private static getMasterKey(): Buffer {
    const keyString = process.env.ENCRYPTION_MASTER_KEY
    if (!keyString || keyString.length < 64) {
      throw new Error('ENCRYPTION_MASTER_KEY must be at least 64 characters hex string')
    }
    return Buffer.from(keyString, 'hex')
  }

  /**
   * æ©Ÿå¯†æƒ…å ±ã®æš—å·åŒ–
   * @param plaintext æš—å·åŒ–å¯¾è±¡ã®ãƒ‡ãƒ¼ã‚¿
   * @param associatedData é–¢é€£ãƒ‡ãƒ¼ã‚¿ï¼ˆAADï¼‰
   * @returns æš—å·åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ï¼ˆBase64ï¼‰
   */
  static encrypt(plaintext: string, associatedData?: string): EncryptionResult {
    try {
      const key = this.getMasterKey()
      const iv = crypto.randomBytes(this.IV_LENGTH)
      const cipher = crypto.createCipher(this.ALGORITHM, key, { iv })

      if (associatedData) {
        cipher.setAAD(Buffer.from(associatedData))
      }

      let encrypted = cipher.update(plaintext, 'utf8')
      encrypted = Buffer.concat([encrypted, cipher.final()])
      const tag = cipher.getAuthTag()

      const result = Buffer.concat([iv, tag, encrypted])

      return {
        encrypted: result.toString('base64'),
        algorithm: this.ALGORITHM,
        timestamp: Date.now()
      }
    } catch (error) {
      throw new EncryptionError('Encryption failed', error)
    }
  }

  /**
   * æ©Ÿå¯†æƒ…å ±ã®å¾©å·åŒ–
   * @param encryptedData æš—å·åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ï¼ˆBase64ï¼‰
   * @param associatedData é–¢é€£ãƒ‡ãƒ¼ã‚¿ï¼ˆAADï¼‰
   * @returns å¾©å·åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿
   */
  static decrypt(encryptedData: string, associatedData?: string): string {
    try {
      const key = this.getMasterKey()
      const data = Buffer.from(encryptedData, 'base64')

      const iv = data.subarray(0, this.IV_LENGTH)
      const tag = data.subarray(this.IV_LENGTH, this.IV_LENGTH + this.TAG_LENGTH)
      const encrypted = data.subarray(this.IV_LENGTH + this.TAG_LENGTH)

      const decipher = crypto.createDecipher(this.ALGORITHM, key, { iv })
      decipher.setAuthTag(tag)

      if (associatedData) {
        decipher.setAAD(Buffer.from(associatedData))
      }

      let decrypted = decipher.update(encrypted, null, 'utf8')
      decrypted += decipher.final('utf8')

      return decrypted
    } catch (error) {
      throw new EncryptionError('Decryption failed', error)
    }
  }

  /**
   * APIã‚­ãƒ¼å°‚ç”¨ã®æš—å·åŒ–
   * @param apiKey APIã‚­ãƒ¼æ–‡å­—åˆ—
   * @param userId ãƒ¦ãƒ¼ã‚¶ãƒ¼IDï¼ˆAADã¨ã—ã¦ä½¿ç”¨ï¼‰
   * @returns æš—å·åŒ–ã•ã‚ŒãŸAPIã‚­ãƒ¼æƒ…å ±
   */
  static encryptApiKey(apiKey: string, userId: string): EncryptedApiKey {
    const associatedData = `apikey:${userId}`
    const encrypted = this.encrypt(apiKey, associatedData)

    return {
      encryptedKey: encrypted.encrypted,
      userId,
      algorithm: encrypted.algorithm,
      createdAt: encrypted.timestamp,
      expiresAt: encrypted.timestamp + (30 * 24 * 60 * 60 * 1000) // 30æ—¥
    }
  }

  /**
   * APIã‚­ãƒ¼ã®å¾©å·åŒ–
   * @param encryptedApiKey æš—å·åŒ–ã•ã‚ŒãŸAPIã‚­ãƒ¼æƒ…å ±
   * @returns å¾©å·åŒ–ã•ã‚ŒãŸAPIã‚­ãƒ¼
   */
  static decryptApiKey(encryptedApiKey: EncryptedApiKey): string {
    if (Date.now() > encryptedApiKey.expiresAt) {
      throw new EncryptionError('Encrypted API key has expired')
    }

    const associatedData = `apikey:${encryptedApiKey.userId}`
    return this.decrypt(encryptedApiKey.encryptedKey, associatedData)
  }

  /**
   * ç’°å¢ƒå¤‰æ•°ã®å®‰å…¨ãªå–å¾—ã¨å¾©å·åŒ–
   * @param envKey ç’°å¢ƒå¤‰æ•°å
   * @param isEncrypted æš—å·åŒ–ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹
   * @returns å¾©å·åŒ–ã•ã‚ŒãŸå€¤
   */
  static getSecureEnvVar(envKey: string, isEncrypted: boolean = true): string {
    const value = process.env[envKey]
    if (!value) {
      throw new EncryptionError(`Environment variable ${envKey} not found`)
    }

    if (!isEncrypted) {
      return value
    }

    try {
      return this.decrypt(value, `env:${envKey}`)
    } catch (error) {
      throw new EncryptionError(`Failed to decrypt environment variable ${envKey}`, error)
    }
  }

  /**
   * ãƒ­ã‚°å®‰å…¨ãªæ–‡å­—åˆ—ã®ç”Ÿæˆ
   * @param sensitive æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿
   * @param visibleChars è¡¨ç¤ºã™ã‚‹æ–‡å­—æ•°
   * @returns ãƒ­ã‚°å®‰å…¨ãªæ–‡å­—åˆ—
   */
  static createLogSafeString(sensitive: string, visibleChars: number = 4): string {
    if (!sensitive || sensitive.length <= visibleChars * 2) {
      return '[REDACTED]'
    }

    const prefix = sensitive.substring(0, visibleChars)
    const suffix = sensitive.substring(sensitive.length - visibleChars)
    const maskedLength = sensitive.length - (visibleChars * 2)

    return `${prefix}${'â—'.repeat(Math.min(maskedLength, 10))}${suffix}`
  }

  /**
   * æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ã®ã‚»ã‚­ãƒ¥ã‚¢ãªå‰Šé™¤
   * @param sensitiveStrings å‰Šé™¤å¯¾è±¡ã®æ–‡å­—åˆ—é…åˆ—
   */
  static secureDelete(...sensitiveStrings: (string | undefined)[]): void {
    // Node.jsã§ã®æ–‡å­—åˆ—ã¯ä¸å¤‰ãªã®ã§ã€å‚ç…§ã‚’nullã«è¨­å®š
    sensitiveStrings.forEach((str, index) => {
      if (str) {
        // ãƒ¡ãƒ¢ãƒªä¸Šã®æ–‡å­—åˆ—ã‚’ä¸Šæ›¸ãï¼ˆå¯èƒ½ãªé™ã‚Šï¼‰
        try {
          if (global.gc) {
            global.gc() // ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å¼·åˆ¶å®Ÿè¡Œï¼ˆ--expose-gcå¿…è¦ï¼‰
          }
        } catch (e) {
          // ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãŒåˆ©ç”¨ã§ããªã„å ´åˆã¯ç„¡è¦–
        }
      }
    })
  }
}

export interface EncryptionResult {
  encrypted: string
  algorithm: string
  timestamp: number
}

export interface EncryptedApiKey {
  encryptedKey: string
  userId: string
  algorithm: string
  createdAt: number
  expiresAt: number
}

export class EncryptionError extends Error {
  constructor(message: string, cause?: any) {
    super(message)
    this.name = 'EncryptionError'
    this.cause = cause
  }
}
```

#### **1.2 ã‚»ã‚­ãƒ¥ã‚¢è¨­å®šç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…**
```typescript
// lib/config/secure-config-manager.ts
import { EncryptionManager } from '@/lib/security/encryption-manager'

export class SecureConfigManager {
  private static configCache = new Map<string, CachedConfig>()
  private static readonly CACHE_TTL = 5 * 60 * 1000 // 5åˆ†

  /**
   * Supabaseè¨­å®šã®å®‰å…¨ãªå–å¾—
   */
  static getSupabaseConfig(): SupabaseConfig {
    const cached = this.getCachedConfig('supabase')
    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
      return cached.config as SupabaseConfig
    }

    try {
      // å…¬é–‹ã‚­ãƒ¼ã¯æš—å·åŒ–ä¸è¦
      const url = process.env.NEXT_PUBLIC_SUPABASE_URL
      const anonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY

      // ã‚µãƒ¼ãƒ“ã‚¹ãƒ­ãƒ¼ãƒ«ã‚­ãƒ¼ã¯æš—å·åŒ–ã•ã‚Œã¦ã„ã‚‹å‰æ
      const serviceRoleKey = EncryptionManager.getSecureEnvVar(
        'SUPABASE_SERVICE_ROLE_KEY_ENCRYPTED',
        true
      )

      if (!url || !anonKey || !serviceRoleKey) {
        throw new ConfigError('Missing required Supabase configuration')
      }

      const config: SupabaseConfig = {
        url,
        anonKey,
        serviceRoleKey
      }

      this.setCachedConfig('supabase', config)
      return config

    } catch (error) {
      throw new ConfigError('Failed to load Supabase configuration', error)
    }
  }

  /**
   * ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®šã®å®‰å…¨ãªå–å¾—
   */
  static getAppConfig(): AppConfig {
    const cached = this.getCachedConfig('app')
    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
      return cached.config as AppConfig
    }

    try {
      const config: AppConfig = {
        appUrl: process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000',
        nodeEnv: process.env.NODE_ENV || 'development',
        encryptionEnabled: process.env.ENCRYPTION_ENABLED !== 'false',
        logLevel: process.env.LOG_LEVEL || 'info',
        rateLimitWindow: parseInt(process.env.RATE_LIMIT_WINDOW_MS || '60000'),
        rateLimitMax: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS || '100')
      }

      this.setCachedConfig('app', config)
      return config

    } catch (error) {
      throw new ConfigError('Failed to load application configuration', error)
    }
  }

  /**
   * ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®šã®å–å¾—
   */
  static getSecurityConfig(): SecurityConfig {
    const cached = this.getCachedConfig('security')
    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
      return cached.config as SecurityConfig
    }

    try {
      // æš—å·åŒ–ã‚­ãƒ¼ã¯å®Ÿè¡Œæ™‚ã«ã®ã¿ãƒ¡ãƒ¢ãƒªã«ä¿æŒ
      const encryptionKey = process.env.ENCRYPTION_MASTER_KEY
      if (!encryptionKey) {
        throw new ConfigError('ENCRYPTION_MASTER_KEY not configured')
      }

      const config: SecurityConfig = {
        encryptionEnabled: true,
        keyRotationEnabled: process.env.KEY_ROTATION_ENABLED === 'true',
        logSensitiveData: process.env.LOG_SENSITIVE_DATA === 'true',
        sessionTimeout: parseInt(process.env.SESSION_TIMEOUT_MS || '86400000'), // 24æ™‚é–“
        maxFailedAttempts: parseInt(process.env.MAX_FAILED_ATTEMPTS || '5'),
        lockoutDuration: parseInt(process.env.LOCKOUT_DURATION_MS || '900000') // 15åˆ†
      }

      this.setCachedConfig('security', config)
      return config

    } catch (error) {
      throw new ConfigError('Failed to load security configuration', error)
    }
  }

  /**
   * ç¬¬ä¸‰è€…ã‚µãƒ¼ãƒ“ã‚¹è¨­å®šã®å®‰å…¨ãªå–å¾—
   */
  static getExternalServiceConfig(): ExternalServiceConfig {
    try {
      const config: ExternalServiceConfig = {
        sentry: {
          dsn: process.env.SENTRY_DSN,
          enabled: !!process.env.SENTRY_DSN
        },
        mixpanel: {
          token: process.env.MIXPANEL_TOKEN,
          enabled: !!process.env.MIXPANEL_TOKEN
        },
        vercel: {
          analyticsEnabled: process.env.VERCEL_ANALYTICS_ENABLED === 'true'
        }
      }

      return config

    } catch (error) {
      throw new ConfigError('Failed to load external service configuration', error)
    }
  }

  /**
   * è¨­å®šã®æ¤œè¨¼
   */
  static validateConfiguration(): ValidationResult {
    const errors: string[] = []
    const warnings: string[] = []

    try {
      // Supabaseè¨­å®šæ¤œè¨¼
      const supabaseConfig = this.getSupabaseConfig()
      if (!supabaseConfig.url.startsWith('https://')) {
        warnings.push('Supabase URL should use HTTPS in production')
      }

      // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®šæ¤œè¨¼
      const securityConfig = this.getSecurityConfig()
      if (!securityConfig.encryptionEnabled) {
        errors.push('Encryption must be enabled in production')
      }

      // ç’°å¢ƒå›ºæœ‰ã®æ¤œè¨¼
      if (process.env.NODE_ENV === 'production') {
        if (process.env.NEXT_PUBLIC_SUPABASE_URL?.includes('localhost')) {
          errors.push('Production should not use localhost URLs')
        }
        if (!process.env.ENCRYPTION_MASTER_KEY) {
          errors.push('ENCRYPTION_MASTER_KEY required in production')
        }
      }

      return {
        valid: errors.length === 0,
        errors,
        warnings
      }

    } catch (error) {
      return {
        valid: false,
        errors: [`Configuration validation failed: ${error.message}`],
        warnings: []
      }
    }
  }

  private static getCachedConfig(key: string): CachedConfig | null {
    return this.configCache.get(key) || null
  }

  private static setCachedConfig(key: string, config: any): void {
    this.configCache.set(key, {
      config,
      timestamp: Date.now()
    })
  }

  /**
   * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
   */
  static clearCache(): void {
    this.configCache.clear()
  }
}

// ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®šç¾©
export interface SupabaseConfig {
  url: string
  anonKey: string
  serviceRoleKey: string
}

export interface AppConfig {
  appUrl: string
  nodeEnv: string
  encryptionEnabled: boolean
  logLevel: string
  rateLimitWindow: number
  rateLimitMax: number
}

export interface SecurityConfig {
  encryptionEnabled: boolean
  keyRotationEnabled: boolean
  logSensitiveData: boolean
  sessionTimeout: number
  maxFailedAttempts: number
  lockoutDuration: number
}

export interface ExternalServiceConfig {
  sentry: {
    dsn?: string
    enabled: boolean
  }
  mixpanel: {
    token?: string
    enabled: boolean
  }
  vercel: {
    analyticsEnabled: boolean
  }
}

export interface ValidationResult {
  valid: boolean
  errors: string[]
  warnings: string[]
}

interface CachedConfig {
  config: any
  timestamp: number
}

export class ConfigError extends Error {
  constructor(message: string, cause?: any) {
    super(message)
    this.name = 'ConfigError'
    this.cause = cause
  }
}
```

#### **1.3 ã‚»ã‚­ãƒ¥ã‚¢ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…**
```typescript
// lib/logging/secure-logger.ts
import { EncryptionManager } from '@/lib/security/encryption-manager'

export class SecureLogger {
  private static readonly LOG_LEVELS = {
    error: 0,
    warn: 1,
    info: 2,
    debug: 3
  }

  private static currentLogLevel = this.LOG_LEVELS.info

  /**
   * ã‚»ã‚­ãƒ¥ã‚¢ãªæƒ…å ±ãƒ­ã‚°
   * @param message ãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
   * @param data ãƒ­ã‚°ãƒ‡ãƒ¼ã‚¿ï¼ˆæ©Ÿå¯†æƒ…å ±ã¯è‡ªå‹•çš„ã«å‰Šé™¤ï¼‰
   */
  static info(message: string, data?: any): void {
    if (this.currentLogLevel >= this.LOG_LEVELS.info) {
      this.writeLog('INFO', message, this.sanitizeLogData(data))
    }
  }

  /**
   * ã‚»ã‚­ãƒ¥ã‚¢ãªã‚¨ãƒ©ãƒ¼ãƒ­ã‚°
   * @param message ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
   * @param error ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   * @param data è¿½åŠ ãƒ‡ãƒ¼ã‚¿
   */
  static error(message: string, error?: any, data?: any): void {
    if (this.currentLogLevel >= this.LOG_LEVELS.error) {
      const errorData = error ? this.sanitizeError(error) : undefined
      this.writeLog('ERROR', message, {
        error: errorData,
        ...this.sanitizeLogData(data)
      })
    }
  }

  /**
   * ã‚»ã‚­ãƒ¥ã‚¢ãªè­¦å‘Šãƒ­ã‚°
   * @param message è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
   * @param data ãƒ­ã‚°ãƒ‡ãƒ¼ã‚¿
   */
  static warn(message: string, data?: any): void {
    if (this.currentLogLevel >= this.LOG_LEVELS.warn) {
      this.writeLog('WARN', message, this.sanitizeLogData(data))
    }
  }

  /**
   * ã‚»ã‚­ãƒ¥ã‚¢ãªãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ï¼ˆæœ¬ç•ªã§ã¯ç„¡åŠ¹åŒ–ï¼‰
   * @param message ãƒ‡ãƒãƒƒã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
   * @param data ãƒ‡ãƒãƒƒã‚°ãƒ‡ãƒ¼ã‚¿
   */
  static debug(message: string, data?: any): void {
    if (process.env.NODE_ENV !== 'production' && this.currentLogLevel >= this.LOG_LEVELS.debug) {
      this.writeLog('DEBUG', message, this.sanitizeLogData(data))
    }
  }

  /**
   * ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆã®å°‚ç”¨ãƒ­ã‚°
   * @param event ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆ
   */
  static security(event: SecurityEvent): void {
    const sanitizedEvent = {
      ...event,
      timestamp: new Date().toISOString(),
      // æ©Ÿå¯†æƒ…å ±ã‚’å‰Šé™¤
      apiKey: event.apiKey ? EncryptionManager.createLogSafeString(event.apiKey) : undefined,
      token: event.token ? EncryptionManager.createLogSafeString(event.token) : undefined,
      credential: undefined, // èªè¨¼æƒ…å ±ã¯å®Œå…¨å‰Šé™¤
      password: undefined    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯å®Œå…¨å‰Šé™¤
    }

    this.writeLog('SECURITY', 'Security Event', sanitizedEvent)

    // æœ¬ç•ªç’°å¢ƒã§ã¯å¤–éƒ¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚µãƒ¼ãƒ“ã‚¹ã«é€ä¿¡
    if (process.env.NODE_ENV === 'production') {
      this.sendToSecurityService(sanitizedEvent)
    }
  }

  /**
   * APIã‚¢ã‚¯ã‚»ã‚¹ãƒ­ã‚°
   * @param request APIãƒªã‚¯ã‚¨ã‚¹ãƒˆæƒ…å ±
   */
  static apiAccess(request: ApiAccessLog): void {
    const sanitizedRequest = {
      ...request,
      timestamp: new Date().toISOString(),
      apiKey: request.apiKey ? EncryptionManager.createLogSafeString(request.apiKey) : undefined,
      userAgent: this.sanitizeUserAgent(request.userAgent),
      headers: this.sanitizeHeaders(request.headers)
    }

    this.writeLog('API', 'API Access', sanitizedRequest)
  }

  private static writeLog(level: string, message: string, data?: any): void {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      pid: process.pid,
      ...(data && { data })
    }

    // æ§‹é€ åŒ–ãƒ­ã‚°ã¨ã—ã¦å‡ºåŠ›
    console.log(JSON.stringify(logEntry))
  }

  private static sanitizeLogData(data: any): any {
    if (!data) return data

    if (typeof data === 'string') {
      return this.sanitizeSensitiveString(data)
    }

    if (Array.isArray(data)) {
      return data.map(item => this.sanitizeLogData(item))
    }

    if (typeof data === 'object') {
      const sanitized: any = {}
      Object.keys(data).forEach(key => {
        if (this.isSensitiveField(key)) {
          sanitized[key] = data[key] ? '[REDACTED]' : undefined
        } else {
          sanitized[key] = this.sanitizeLogData(data[key])
        }
      })
      return sanitized
    }

    return data
  }

  private static sanitizeError(error: any): any {
    if (error instanceof Error) {
      return {
        name: error.name,
        message: this.sanitizeSensitiveString(error.message),
        stack: process.env.NODE_ENV === 'production' ? undefined : error.stack
      }
    }
    return this.sanitizeLogData(error)
  }

  private static sanitizeSensitiveString(str: string): string {
    const sensitivePatterns = [
      /\b[A-Za-z0-9]{20,}\b/g,  // APIã‚­ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³
      /\beyJ[A-Za-z0-9_-]+/g,   // JWTãƒˆãƒ¼ã‚¯ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³
      /\bsk_[A-Za-z0-9_]+/g,    // Stripeã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚­ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³
      /\bpassword[^\s]*/gi,      // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
      /\bsecret[^\s]*/gi,        // ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
      /\btoken[^\s]*/gi          // ãƒˆãƒ¼ã‚¯ãƒ³ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
    ]

    let sanitized = str
    sensitivePatterns.forEach(pattern => {
      sanitized = sanitized.replace(pattern, '[REDACTED]')
    })

    return sanitized
  }

  private static isSensitiveField(fieldName: string): boolean {
    const sensitiveFields = [
      'password', 'secret', 'token', 'apikey', 'api_key',
      'credential', 'auth', 'authorization', 'key',
      'private', 'confidential', 'sensitive'
    ]

    return sensitiveFields.some(field =>
      fieldName.toLowerCase().includes(field)
    )
  }

  private static sanitizeUserAgent(userAgent?: string): string | undefined {
    if (!userAgent) return undefined

    // æ©Ÿå¯†æƒ…å ±ãŒå«ã¾ã‚Œã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹User-Agentã‚’ã‚µãƒ‹ã‚¿ã‚¤ã‚º
    return userAgent.replace(/\b[A-Za-z0-9]{20,}\b/g, '[REDACTED]')
  }

  private static sanitizeHeaders(headers?: Record<string, string>): Record<string, string> | undefined {
    if (!headers) return undefined

    const sanitized: Record<string, string> = {}
    Object.keys(headers).forEach(key => {
      if (this.isSensitiveField(key)) {
        sanitized[key] = '[REDACTED]'
      } else {
        sanitized[key] = headers[key]
      }
    })

    return sanitized
  }

  private static async sendToSecurityService(event: any): Promise<void> {
    try {
      // å¤–éƒ¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚µãƒ¼ãƒ“ã‚¹ã¸ã®é€ä¿¡ãƒ­ã‚¸ãƒƒã‚¯
      // ä¾‹: Sentryã€Datadogã€Splunkç­‰
      console.log('ğŸ”’ Security Event:', event)
    } catch (error) {
      console.error('Failed to send security event to external service:', error)
    }
  }

  /**
   * ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã®è¨­å®š
   * @param level ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«
   */
  static setLogLevel(level: 'error' | 'warn' | 'info' | 'debug'): void {
    this.currentLogLevel = this.LOG_LEVELS[level]
  }
}

export interface SecurityEvent {
  type: 'AUTH_FAILURE' | 'SUSPICIOUS_ACCESS' | 'DATA_BREACH' | 'SECURITY_VIOLATION'
  userId?: string
  ipAddress?: string
  userAgent?: string
  apiKey?: string
  token?: string
  credential?: string
  password?: string
  details: any
}

export interface ApiAccessLog {
  method: string
  endpoint: string
  statusCode: number
  responseTime: number
  apiKey?: string
  userId?: string
  ipAddress?: string
  userAgent?: string
  headers?: Record<string, string>
}
```

### **Phase 2: åŒ…æ‹¬çš„ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–ï¼ˆ1é€±é–“ï¼‰**

#### **2.1 ã‚»ã‚­ãƒ¥ã‚¢APIã‚­ãƒ¼ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ **
```typescript
// lib/security/secure-api-key-manager.ts
import { EncryptionManager, EncryptedApiKey } from './encryption-manager'
import { SecureLogger } from '@/lib/logging/secure-logger'

export class SecureApiKeyManager {
  /**
   * APIã‚­ãƒ¼ã®å®‰å…¨ãªç”Ÿæˆ
   * @param userId ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
   * @param keyName ã‚­ãƒ¼å
   * @returns æš—å·åŒ–ã•ã‚ŒãŸAPIã‚­ãƒ¼æƒ…å ±
   */
  static async generateSecureApiKey(
    userId: string,
    keyName: string
  ): Promise<SecureApiKeyResult> {
    try {
      // ç”Ÿæˆæ™‚åˆ»ã‚’saltã¨ã—ã¦ä½¿ç”¨
      const timestamp = Date.now()
      const randomBytes = crypto.getRandomValues(new Uint8Array(32))

      // ã‚»ã‚­ãƒ¥ã‚¢ãªAPIã‚­ãƒ¼ç”Ÿæˆ
      const keyComponents = [
        'xbrl_secure',
        timestamp.toString(16),
        Array.from(randomBytes, b => b.toString(16).padStart(2, '0')).join('')
      ]
      const plainApiKey = keyComponents.join('_')

      // æš—å·åŒ–ã—ã¦ä¿å­˜
      const encryptedKey = EncryptionManager.encryptApiKey(plainApiKey, userId)

      // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜ã™ã‚‹æƒ…å ±ï¼ˆæš—å·åŒ–æ¸ˆã¿ï¼‰
      const dbRecord = {
        id: crypto.randomUUID(),
        userId,
        name: keyName,
        encryptedKey: encryptedKey.encryptedKey,
        algorithm: encryptedKey.algorithm,
        createdAt: encryptedKey.createdAt,
        expiresAt: encryptedKey.expiresAt,
        isActive: true,
        lastUsed: null,
        usageCount: 0
      }

      // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ­ã‚°
      SecureLogger.security({
        type: 'AUTH_FAILURE',
        userId,
        details: {
          action: 'api_key_generated',
          keyName,
          keyId: dbRecord.id
        }
      })

      return {
        success: true,
        keyId: dbRecord.id,
        plainKey: plainApiKey, // ä¸€åº¦ã ã‘è¿”å´
        maskedKey: EncryptionManager.createLogSafeString(plainApiKey),
        dbRecord,
        // å¹³æ–‡ã‚­ãƒ¼ã®è‡ªå‹•å‰Šé™¤
        cleanup: () => EncryptionManager.secureDelete(plainApiKey)
      }

    } catch (error) {
      SecureLogger.error('API key generation failed', error, { userId, keyName })
      return {
        success: false,
        error: 'Failed to generate secure API key'
      }
    }
  }

  /**
   * APIã‚­ãƒ¼ã®å®‰å…¨ãªæ¤œè¨¼
   * @param providedKey æä¾›ã•ã‚ŒãŸAPIã‚­ãƒ¼
   * @returns æ¤œè¨¼çµæœ
   */
  static async verifySecureApiKey(providedKey: string): Promise<ApiKeyVerification> {
    try {
      const startTime = Date.now()

      // ã‚­ãƒ¼ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®åŸºæœ¬æ¤œè¨¼
      if (!providedKey || !providedKey.startsWith('xbrl_secure_')) {
        return {
          valid: false,
          error: 'Invalid API key format',
          processingTime: Date.now() - startTime
        }
      }

      // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰æš—å·åŒ–ã•ã‚ŒãŸã‚­ãƒ¼ã‚’æ¤œç´¢
      // ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ã‚­ãƒ¼ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–ã—ã¦ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ¤œç´¢ï¼‰
      const keyPrefix = providedKey.substring(0, 20)
      const hashedPrefix = crypto.createHash('sha256').update(keyPrefix).digest('hex')

      // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¤œç´¢ï¼ˆç–‘ä¼¼ã‚³ãƒ¼ãƒ‰ï¼‰
      const dbRecord = await this.findKeyByHashedPrefix(hashedPrefix)
      if (!dbRecord) {
        return {
          valid: false,
          error: 'API key not found',
          processingTime: Date.now() - startTime
        }
      }

      // æœ‰åŠ¹æœŸé™ãƒã‚§ãƒƒã‚¯
      if (Date.now() > dbRecord.expiresAt) {
        return {
          valid: false,
          error: 'API key expired',
          processingTime: Date.now() - startTime
        }
      }

      // æš—å·åŒ–ã•ã‚ŒãŸã‚­ãƒ¼ã‚’å¾©å·åŒ–ã—ã¦æ¯”è¼ƒ
      const encryptedApiKey: EncryptedApiKey = {
        encryptedKey: dbRecord.encryptedKey,
        userId: dbRecord.userId,
        algorithm: dbRecord.algorithm,
        createdAt: dbRecord.createdAt,
        expiresAt: dbRecord.expiresAt
      }

      const decryptedKey = EncryptionManager.decryptApiKey(encryptedApiKey)

      // å®šæ•°æ™‚é–“æ¯”è¼ƒ
      const providedHash = crypto.createHash('sha256').update(providedKey).digest('hex')
      const storedHash = crypto.createHash('sha256').update(decryptedKey).digest('hex')
      const isValid = crypto.timingSafeEqual(
        Buffer.from(providedHash, 'hex'),
        Buffer.from(storedHash, 'hex')
      )

      if (isValid) {
        // ä½¿ç”¨å›æ•°ã®æ›´æ–°
        await this.updateKeyUsage(dbRecord.id)

        // å¹³æ–‡ã‚­ãƒ¼ã®ã‚»ã‚­ãƒ¥ã‚¢ãªå‰Šé™¤
        EncryptionManager.secureDelete(decryptedKey)

        return {
          valid: true,
          userId: dbRecord.userId,
          keyId: dbRecord.id,
          keyName: dbRecord.name,
          processingTime: Date.now() - startTime
        }
      } else {
        SecureLogger.security({
          type: 'SUSPICIOUS_ACCESS',
          details: {
            action: 'invalid_api_key_attempt',
            providedKeyPrefix: EncryptionManager.createLogSafeString(providedKey),
            keyId: dbRecord.id
          }
        })

        return {
          valid: false,
          error: 'Invalid API key',
          processingTime: Date.now() - startTime
        }
      }

    } catch (error) {
      SecureLogger.error('API key verification failed', error, {
        keyPrefix: EncryptionManager.createLogSafeString(providedKey)
      })

      return {
        valid: false,
        error: 'API key verification error',
        processingTime: Date.now() - startTime
      }
    }
  }

  /**
   * APIã‚­ãƒ¼ã®å®‰å…¨ãªå‰Šé™¤
   * @param keyId ã‚­ãƒ¼ID
   * @param userId ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
   * @returns å‰Šé™¤çµæœ
   */
  static async revokeSecureApiKey(keyId: string, userId: string): Promise<RevocationResult> {
    try {
      // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰å‰Šé™¤ï¼ˆè«–ç†å‰Šé™¤ï¼‰
      const result = await this.deactivateKey(keyId, userId)

      if (result.success) {
        SecureLogger.security({
          type: 'AUTH_FAILURE',
          userId,
          details: {
            action: 'api_key_revoked',
            keyId
          }
        })

        return {
          success: true,
          keyId
        }
      } else {
        return {
          success: false,
          error: 'Failed to revoke API key'
        }
      }

    } catch (error) {
      SecureLogger.error('API key revocation failed', error, { keyId, userId })
      return {
        success: false,
        error: 'API key revocation error'
      }
    }
  }

  private static async findKeyByHashedPrefix(hashedPrefix: string): Promise<any> {
    // å®Ÿéš›ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¤œç´¢å®Ÿè£…
    // Supabaseã®å ´åˆ: RPCé–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ã‚»ã‚­ãƒ¥ã‚¢ã«æ¤œç´¢
    return null // ç–‘ä¼¼ã‚³ãƒ¼ãƒ‰
  }

  private static async updateKeyUsage(keyId: string): Promise<void> {
    // ä½¿ç”¨å›æ•°ã¨æœ€çµ‚ä½¿ç”¨æ—¥æ™‚ã®æ›´æ–°
  }

  private static async deactivateKey(keyId: string, userId: string): Promise<{success: boolean}> {
    // ã‚­ãƒ¼ã®ç„¡åŠ¹åŒ–ï¼ˆè«–ç†å‰Šé™¤ï¼‰
    return { success: true }
  }
}

export interface SecureApiKeyResult {
  success: boolean
  keyId?: string
  plainKey?: string
  maskedKey?: string
  dbRecord?: any
  cleanup?: () => void
  error?: string
}

export interface ApiKeyVerification {
  valid: boolean
  userId?: string
  keyId?: string
  keyName?: string
  error?: string
  processingTime: number
}

export interface RevocationResult {
  success: boolean
  keyId?: string
  error?: string
}
```

#### **2.2 ã‚»ã‚­ãƒ¥ã‚¢ãªç’°å¢ƒå¤‰æ•°ç®¡ç†**
```bash
# .env.encrypted.example - æš—å·åŒ–ç‰ˆã®ç’°å¢ƒå¤‰æ•°ä¾‹
# ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‚è€ƒã« .env.encrypted ã‚’ä½œæˆã—ã¦ãã ã•ã„

# ============================================
# æš—å·åŒ–ã•ã‚ŒãŸSupabaseè¨­å®š
# ============================================
# å…¬é–‹å¯èƒ½ãªè¨­å®š
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key

# æš—å·åŒ–ã•ã‚ŒãŸã‚µãƒ¼ãƒ“ã‚¹ãƒ­ãƒ¼ãƒ«ã‚­ãƒ¼
SUPABASE_SERVICE_ROLE_KEY_ENCRYPTED=base64-encrypted-service-role-key

# ============================================
# æš—å·åŒ–ãƒã‚¹ã‚¿ãƒ¼ã‚­ãƒ¼ï¼ˆå¤–éƒ¨ç§˜å¯†ç®¡ç†ã‚µãƒ¼ãƒ“ã‚¹ã‹ã‚‰å–å¾—ï¼‰
# ============================================
# æœ¬ç•ªç’°å¢ƒã§ã¯ç’°å¢ƒå¤‰æ•°ã¨ã—ã¦è¨­å®šã›ãšã€Azure Key Vaultã€AWS Secrets Managerã€
# Google Secret Managerç­‰ã‹ã‚‰å‹•çš„ã«å–å¾—
ENCRYPTION_MASTER_KEY=64æ–‡å­—ä»¥ä¸Šã®hexæ–‡å­—åˆ—

# ============================================
# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š
# ============================================
ENCRYPTION_ENABLED=true
KEY_ROTATION_ENABLED=true
LOG_SENSITIVE_DATA=false
SESSION_TIMEOUT_MS=86400000
MAX_FAILED_ATTEMPTS=5
LOCKOUT_DURATION_MS=900000

# ============================================
# ãƒ­ã‚°è¨­å®š
# ============================================
LOG_LEVEL=info
STRUCTURED_LOGGING=true
SECURITY_LOG_ENABLED=true

# ============================================
# å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹è¨­å®š
# ============================================
# ã“ã‚Œã‚‰ã‚‚å¿…è¦ã«å¿œã˜ã¦æš—å·åŒ–
SENTRY_DSN_ENCRYPTED=base64-encrypted-sentry-dsn
MIXPANEL_TOKEN_ENCRYPTED=base64-encrypted-mixpanel-token
```

```typescript
// scripts/encrypt-env-vars.ts - ç’°å¢ƒå¤‰æ•°æš—å·åŒ–ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
import { EncryptionManager } from '@/lib/security/encryption-manager'
import fs from 'fs'
import path from 'path'

interface EnvironmentVars {
  [key: string]: string
}

class EnvEncryptor {
  private static readonly SENSITIVE_VARS = [
    'SUPABASE_SERVICE_ROLE_KEY',
    'ENCRYPTION_MASTER_KEY',
    'SENTRY_DSN',
    'MIXPANEL_TOKEN',
    'DATABASE_PASSWORD',
    'JWT_SECRET',
    'OAUTH_CLIENT_SECRET'
  ]

  /**
   * ç’°å¢ƒå¤‰æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã®æš—å·åŒ–
   */
  static async encryptEnvFile(inputFile: string, outputFile: string): Promise<void> {
    try {
      console.log(`ğŸ” Encrypting environment variables from ${inputFile}...`)

      const envContent = fs.readFileSync(inputFile, 'utf-8')
      const envVars = this.parseEnvFile(envContent)

      const encryptedVars: EnvironmentVars = {}

      Object.keys(envVars).forEach(key => {
        if (this.SENSITIVE_VARS.includes(key)) {
          console.log(`ğŸ”’ Encrypting ${key}...`)
          const encrypted = EncryptionManager.encrypt(envVars[key], `env:${key}`)
          encryptedVars[`${key}_ENCRYPTED`] = encrypted.encrypted
        } else {
          encryptedVars[key] = envVars[key]
        }
      })

      const outputContent = this.generateEnvFile(encryptedVars)
      fs.writeFileSync(outputFile, outputContent)

      console.log(`âœ… Encrypted environment variables saved to ${outputFile}`)
      console.log(`âš ï¸  Remember to delete the original ${inputFile} file`)

    } catch (error) {
      console.error('âŒ Failed to encrypt environment variables:', error)
      process.exit(1)
    }
  }

  /**
   * æš—å·åŒ–ã•ã‚ŒãŸç’°å¢ƒå¤‰æ•°ã®å¾©å·åŒ–ï¼ˆé–‹ç™ºç”¨ï¼‰
   */
  static async decryptEnvFile(inputFile: string, outputFile: string): Promise<void> {
    try {
      console.log(`ğŸ”“ Decrypting environment variables from ${inputFile}...`)

      const envContent = fs.readFileSync(inputFile, 'utf-8')
      const envVars = this.parseEnvFile(envContent)

      const decryptedVars: EnvironmentVars = {}

      Object.keys(envVars).forEach(key => {
        if (key.endsWith('_ENCRYPTED')) {
          const originalKey = key.replace('_ENCRYPTED', '')
          console.log(`ğŸ”“ Decrypting ${originalKey}...`)
          const decrypted = EncryptionManager.decrypt(envVars[key], `env:${originalKey}`)
          decryptedVars[originalKey] = decrypted
        } else {
          decryptedVars[key] = envVars[key]
        }
      })

      const outputContent = this.generateEnvFile(decryptedVars)
      fs.writeFileSync(outputFile, outputContent)

      console.log(`âœ… Decrypted environment variables saved to ${outputFile}`)
      console.log(`âš ï¸  Use decrypted file only for development`)

    } catch (error) {
      console.error('âŒ Failed to decrypt environment variables:', error)
      process.exit(1)
    }
  }

  private static parseEnvFile(content: string): EnvironmentVars {
    const vars: EnvironmentVars = {}
    const lines = content.split('\n')

    lines.forEach(line => {
      line = line.trim()
      if (line && !line.startsWith('#')) {
        const [key, ...valueParts] = line.split('=')
        if (key && valueParts.length > 0) {
          vars[key] = valueParts.join('=')
        }
      }
    })

    return vars
  }

  private static generateEnvFile(vars: EnvironmentVars): string {
    const lines = [
      '# ============================================',
      '# Encrypted Environment Variables',
      '# ============================================',
      '# Generated by EnvEncryptor',
      `# Generated at: ${new Date().toISOString()}`,
      '# ============================================',
      ''
    ]

    Object.keys(vars).forEach(key => {
      lines.push(`${key}=${vars[key]}`)
    })

    return lines.join('\n')
  }

  /**
   * ãƒã‚¹ã‚¿ãƒ¼ã‚­ãƒ¼ã®ç”Ÿæˆ
   */
  static generateMasterKey(): string {
    const key = crypto.getRandomValues(new Uint8Array(32))
    return Array.from(key, b => b.toString(16).padStart(2, '0')).join('')
  }
}

// CLIå®Ÿè¡Œ
if (require.main === module) {
  const args = process.argv.slice(2)
  const command = args[0]

  switch (command) {
    case 'encrypt':
      const inputFile = args[1] || '.env.local'
      const outputFile = args[2] || '.env.encrypted'
      EnvEncryptor.encryptEnvFile(inputFile, outputFile)
      break

    case 'decrypt':
      const encryptedFile = args[1] || '.env.encrypted'
      const decryptedFile = args[2] || '.env.decrypted'
      EnvEncryptor.decryptEnvFile(encryptedFile, decryptedFile)
      break

    case 'generate-key':
      const masterKey = EnvEncryptor.generateMasterKey()
      console.log('ğŸ”‘ Generated Master Key:')
      console.log(masterKey)
      console.log('\nâš ï¸  Store this key securely in your secret management system')
      break

    default:
      console.log('Usage:')
      console.log('  npm run encrypt-env encrypt [input-file] [output-file]')
      console.log('  npm run encrypt-env decrypt [encrypted-file] [output-file]')
      console.log('  npm run encrypt-env generate-key')
      break
  }
}

export { EnvEncryptor }
```

### **Phase 3: åŒ…æ‹¬çš„ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆï¼ˆ2é€±é–“ï¼‰**

#### **3.1 æ©Ÿå¯†æƒ…å ±ä¿è­·ãƒ†ã‚¹ãƒˆ**
```typescript
// tests/security/sensitive-data-protection.test.ts
import { describe, test, expect, beforeEach, afterEach } from '@jest/globals'
import { EncryptionManager } from '@/lib/security/encryption-manager'
import { SecureLogger } from '@/lib/logging/secure-logger'
import { SecureConfigManager } from '@/lib/config/secure-config-manager'

describe('Sensitive Data Protection Tests', () => {
  describe('Encryption Manager Tests', () => {
    test('should encrypt and decrypt data correctly', () => {
      const plaintext = 'supabase_service_role_key_12345'
      const associatedData = 'env:SUPABASE_SERVICE_ROLE_KEY'

      const encrypted = EncryptionManager.encrypt(plaintext, associatedData)
      expect(encrypted.encrypted).toBeTruthy()
      expect(encrypted.encrypted).not.toContain(plaintext)

      const decrypted = EncryptionManager.decrypt(encrypted.encrypted, associatedData)
      expect(decrypted).toBe(plaintext)
    })

    test('should fail decryption with wrong associated data', () => {
      const plaintext = 'secret_data'
      const correctAAD = 'env:TEST_KEY'
      const wrongAAD = 'env:WRONG_KEY'

      const encrypted = EncryptionManager.encrypt(plaintext, correctAAD)

      expect(() => {
        EncryptionManager.decrypt(encrypted.encrypted, wrongAAD)
      }).toThrow()
    })

    test('should encrypt API keys with user context', () => {
      const apiKey = 'xbrl_secure_1234567890abcdef'
      const userId = 'user123'

      const encrypted = EncryptionManager.encryptApiKey(apiKey, userId)
      expect(encrypted.encryptedKey).toBeTruthy()
      expect(encrypted.userId).toBe(userId)
      expect(encrypted.expiresAt).toBeGreaterThan(Date.now())

      const decrypted = EncryptionManager.decryptApiKey(encrypted)
      expect(decrypted).toBe(apiKey)
    })

    test('should create log safe strings', () => {
      const sensitiveData = 'xbrl_secure_very_long_secret_key_12345'
      const logSafe = EncryptionManager.createLogSafeString(sensitiveData, 4)

      expect(logSafe).not.toBe(sensitiveData)
      expect(logSafe).toContain('xbrl')
      expect(logSafe).toContain('2345')
      expect(logSafe).toContain('â—')
    })

    test('should handle expired encrypted API keys', () => {
      const apiKey = 'xbrl_secure_expired_key'
      const userId = 'user123'

      const encrypted = EncryptionManager.encryptApiKey(apiKey, userId)
      // Force expiration
      encrypted.expiresAt = Date.now() - 1000

      expect(() => {
        EncryptionManager.decryptApiKey(encrypted)
      }).toThrow('Encrypted API key has expired')
    })
  })

  describe('Secure Configuration Tests', () => {
    test('should validate configuration requirements', () => {
      const validation = SecureConfigManager.validateConfiguration()

      // è¨­å®šæ¤œè¨¼ãŒé©åˆ‡ã«å‹•ä½œã™ã‚‹ã“ã¨ã‚’ç¢ºèª
      expect(validation.valid).toBeDefined()
      expect(validation.errors).toBeDefined()
      expect(validation.warnings).toBeDefined()
    })

    test('should cache configuration securely', () => {
      // åˆå›å–å¾—
      const config1 = SecureConfigManager.getAppConfig()

      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å–å¾—
      const config2 = SecureConfigManager.getAppConfig()

      expect(config1).toEqual(config2)
      expect(config1.encryptionEnabled).toBeTruthy()
    })

    test('should clear cache when requested', () => {
      SecureConfigManager.getAppConfig() // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
      SecureConfigManager.clearCache()

      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢å¾Œã‚‚æ­£å¸¸ã«å–å¾—ã§ãã‚‹ã“ã¨ã‚’ç¢ºèª
      const config = SecureConfigManager.getAppConfig()
      expect(config).toBeTruthy()
    })
  })

  describe('Secure Logging Tests', () => {
    let consoleOutput: string[] = []
    let originalLog: any

    beforeEach(() => {
      consoleOutput = []
      originalLog = console.log
      console.log = (message: string) => {
        consoleOutput.push(message)
      }
    })

    afterEach(() => {
      console.log = originalLog
    })

    test('should sanitize sensitive data in logs', () => {
      const sensitiveData = {
        username: 'testuser',
        password: 'secret123',
        apiKey: 'xbrl_secure_abcdef123456',
        normalField: 'normal_value'
      }

      SecureLogger.info('Test log with sensitive data', sensitiveData)

      const logOutput = consoleOutput.join(' ')
      expect(logOutput).toContain('testuser')
      expect(logOutput).toContain('normal_value')
      expect(logOutput).not.toContain('secret123')
      expect(logOutput).not.toContain('xbrl_secure_abcdef123456')
      expect(logOutput).toContain('[REDACTED]')
    })

    test('should sanitize error messages', () => {
      const sensitiveError = new Error('Database connection failed with key xbrl_secure_12345')

      SecureLogger.error('Test error', sensitiveError)

      const logOutput = consoleOutput.join(' ')
      expect(logOutput).toContain('Database connection failed')
      expect(logOutput).not.toContain('xbrl_secure_12345')
      expect(logOutput).toContain('[REDACTED]')
    })

    test('should log security events appropriately', () => {
      SecureLogger.security({
        type: 'SUSPICIOUS_ACCESS',
        userId: 'user123',
        apiKey: 'xbrl_secure_suspicious_key',
        details: {
          action: 'multiple_failed_attempts',
          attempts: 5
        }
      })

      const logOutput = consoleOutput.join(' ')
      expect(logOutput).toContain('SECURITY')
      expect(logOutput).toContain('SUSPICIOUS_ACCESS')
      expect(logOutput).toContain('user123')
      expect(logOutput).not.toContain('xbrl_secure_suspicious_key')
      expect(logOutput).toContain('multiple_failed_attempts')
    })

    test('should not log debug messages in production', () => {
      const originalEnv = process.env.NODE_ENV
      process.env.NODE_ENV = 'production'

      SecureLogger.debug('Debug message with sensitive data', {
        password: 'secret123'
      })

      process.env.NODE_ENV = originalEnv

      expect(consoleOutput).toHaveLength(0)
    })
  })

  describe('Integration Tests', () => {
    test('should handle complete encryption workflow', async () => {
      // APIã‚­ãƒ¼ç”Ÿæˆ
      const userId = 'test-user-123'
      const keyName = 'Test API Key'

      // ç”Ÿæˆ
      const generateResult = await SecureApiKeyManager.generateSecureApiKey(userId, keyName)
      expect(generateResult.success).toBe(true)
      expect(generateResult.plainKey).toBeTruthy()
      expect(generateResult.maskedKey).toBeTruthy()

      // æ¤œè¨¼
      const verifyResult = await SecureApiKeyManager.verifySecureApiKey(generateResult.plainKey!)
      expect(verifyResult.valid).toBe(true)
      expect(verifyResult.userId).toBe(userId)

      // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      if (generateResult.cleanup) {
        generateResult.cleanup()
      }

      // å‰Šé™¤
      const revokeResult = await SecureApiKeyManager.revokeSecureApiKey(
        generateResult.keyId!,
        userId
      )
      expect(revokeResult.success).toBe(true)
    })

    test('should detect and prevent sensitive data exposure', () => {
      const testData = {
        user: 'testuser',
        supabase_key: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9',
        api_token: 'xbrl_secure_long_secret_key_12345',
        normal_data: 'this is normal'
      }

      // ãƒ­ã‚°å‡ºåŠ›ãƒ†ã‚¹ãƒˆ
      const consoleOutput: string[] = []
      const originalLog = console.log
      console.log = (message: string) => consoleOutput.push(message)

      SecureLogger.info('Test with mixed data', testData)

      console.log = originalLog

      const logOutput = consoleOutput.join(' ')
      expect(logOutput).toContain('testuser')
      expect(logOutput).toContain('this is normal')
      expect(logOutput).not.toContain('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9')
      expect(logOutput).not.toContain('xbrl_secure_long_secret_key_12345')
    })
  })

  describe('Performance Tests', () => {
    test('should encrypt/decrypt within acceptable time limits', () => {
      const plaintext = 'test_secret_data_' + 'x'.repeat(1000)

      const startTime = performance.now()
      const encrypted = EncryptionManager.encrypt(plaintext)
      const encryptTime = performance.now() - startTime

      const decryptStartTime = performance.now()
      const decrypted = EncryptionManager.decrypt(encrypted.encrypted)
      const decryptTime = performance.now() - decryptStartTime

      expect(encryptTime).toBeLessThan(10) // 10msä»¥ä¸‹
      expect(decryptTime).toBeLessThan(10) // 10msä»¥ä¸‹
      expect(decrypted).toBe(plaintext)
    })

    test('should handle batch encryption efficiently', () => {
      const testData = Array(100).fill(0).map((_, i) => `secret_data_${i}`)

      const startTime = performance.now()
      const encrypted = testData.map(data => EncryptionManager.encrypt(data))
      const totalTime = performance.now() - startTime

      expect(totalTime).toBeLessThan(100) // 100msä»¥ä¸‹
      expect(encrypted).toHaveLength(100)
    })
  })
})
```

#### **3.2 ç’°å¢ƒå¤‰æ•°ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ**
```typescript
// tests/security/environment-security.test.ts
import { describe, test, expect } from '@jest/globals'
import fs from 'fs'
import path from 'path'

describe('Environment Variable Security Tests', () => {
  describe('Environment File Analysis', () => {
    test('should not contain plaintext sensitive data', () => {
      const envFiles = [
        '.env.example',
        '.env.local.example',
        '.env.production.example'
      ].map(file => path.join(process.cwd(), file))
        .filter(file => fs.existsSync(file))

      envFiles.forEach(envFile => {
        const content = fs.readFileSync(envFile, 'utf-8')

        // å®Ÿéš›ã®ã‚­ãƒ¼å€¤ãŒå«ã¾ã‚Œã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
        const suspiciousPatterns = [
          /eyJ[A-Za-z0-9_-]{10,}/,  // JWT tokens
          /sk_[a-zA-Z0-9_]{20,}/,   // Stripe secret keys
          /xbrl_[a-zA-Z0-9_]{20,}/, // Real API keys
          /[a-fA-F0-9]{32,}/        // Hex keys
        ]

        suspiciousPatterns.forEach(pattern => {
          expect(content).not.toMatch(pattern)
        })
      })
    })

    test('should use placeholder values in example files', () => {
      const exampleFiles = [
        '.env.example'
      ].map(file => path.join(process.cwd(), file))
        .filter(file => fs.existsSync(file))

      exampleFiles.forEach(envFile => {
        const content = fs.readFileSync(envFile, 'utf-8')

        // ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼å€¤ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
        expect(content).toMatch(/your-project\.supabase\.co/)
        expect(content).toMatch(/your-anon-key/)
        expect(content).toMatch(/your-service-role-key/)
      })
    })
  })

  describe('Runtime Environment Validation', () => {
    test('should validate required environment variables', () => {
      const requiredVars = [
        'NEXT_PUBLIC_SUPABASE_URL',
        'NEXT_PUBLIC_SUPABASE_ANON_KEY'
      ]

      requiredVars.forEach(varName => {
        const value = process.env[varName]
        expect(value).toBeTruthy()
        expect(value).not.toBe('your-placeholder-value')
      })
    })

    test('should handle encrypted environment variables', () => {
      // æš—å·åŒ–ã•ã‚ŒãŸç’°å¢ƒå¤‰æ•°ã®ãƒ†ã‚¹ãƒˆ
      const encryptedVars = [
        'SUPABASE_SERVICE_ROLE_KEY_ENCRYPTED',
        'SENTRY_DSN_ENCRYPTED'
      ]

      encryptedVars.forEach(varName => {
        const value = process.env[varName]
        if (value) {
          // Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸæš—å·åŒ–ãƒ‡ãƒ¼ã‚¿ã®å½¢å¼ç¢ºèª
          expect(() => Buffer.from(value, 'base64')).not.toThrow()
        }
      })
    })
  })

  describe('Configuration Security', () => {
    test('should not expose sensitive configuration in client bundle', () => {
      // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§åˆ©ç”¨å¯èƒ½ãªç’°å¢ƒå¤‰æ•°ã®ç¢ºèª
      const clientVars = Object.keys(process.env).filter(key =>
        key.startsWith('NEXT_PUBLIC_')
      )

      clientVars.forEach(varName => {
        const value = process.env[varName]

        // æ©Ÿå¯†æƒ…å ±ãŒå«ã¾ã‚Œã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
        expect(varName).not.toMatch(/SECRET|PRIVATE|KEY(?!_URL)/i)

        if (value) {
          expect(value).not.toMatch(/eyJ[A-Za-z0-9_-]{10,}/) // No JWT tokens
          expect(value).not.toMatch(/sk_[a-zA-Z0-9_]{20,}/)  // No secret keys
        }
      })
    })

    test('should use HTTPS in production URLs', () => {
      if (process.env.NODE_ENV === 'production') {
        const publicUrls = [
          'NEXT_PUBLIC_SUPABASE_URL',
          'NEXT_PUBLIC_APP_URL'
        ]

        publicUrls.forEach(varName => {
          const value = process.env[varName]
          if (value) {
            expect(value).toMatch(/^https:\/\//)
          }
        })
      }
    })
  })

  describe('Logging Security', () => {
    test('should not log sensitive environment variables', () => {
      const consoleOutput: string[] = []
      const originalLog = console.log
      const originalError = console.error

      console.log = (message: string) => consoleOutput.push(message)
      console.error = (message: string) => consoleOutput.push(message)

      // ç’°å¢ƒå¤‰æ•°ã‚’å«ã‚€å¯èƒ½æ€§ã®ã‚ã‚‹ãƒ­ã‚°ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
      console.log('Environment:', process.env)
      console.error('Config error:', { env: process.env })

      console.log = originalLog
      console.error = originalError

      const logOutput = consoleOutput.join(' ')

      // æ©Ÿå¯†æƒ…å ±ãŒãƒ­ã‚°ã«å«ã¾ã‚Œã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
      const sensitivePatterns = [
        /eyJ[A-Za-z0-9_-]{10,}/,  // JWT tokens
        /sk_[a-zA-Z0-9_]{20,}/,   // Stripe keys
        /supabase.*key/i
      ]

      sensitivePatterns.forEach(pattern => {
        expect(logOutput).not.toMatch(pattern)
      })
    })
  })
})
```

---

## ğŸ“Š ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åŠ¹æœæ¸¬å®š

### **å®Ÿè£…å‰å¾Œã®æ¯”è¼ƒ**
```yaml
å®Ÿè£…å‰ã®çŠ¶æ…‹:
  æ©Ÿå¯†æƒ…å ±ä¿è­·ãƒ¬ãƒ™ãƒ«: ğŸ”´ LOW (2.1/10)
  å¹³æ–‡ä¿å­˜: âŒ APIã‚­ãƒ¼ã€ãƒˆãƒ¼ã‚¯ãƒ³ã€è¨­å®šæƒ…å ±
  æš—å·åŒ–ã‚·ã‚¹ãƒ†ãƒ : âŒ ãªã—
  ãƒ­ã‚°ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£: âŒ æ©Ÿå¯†æƒ…å ±æ¼æ´©ãƒªã‚¹ã‚¯
  ç’°å¢ƒå¤‰æ•°ç®¡ç†: âŒ å¹³æ–‡ä¿å­˜

å®Ÿè£…å¾Œã®çŠ¶æ…‹:
  æ©Ÿå¯†æƒ…å ±ä¿è­·ãƒ¬ãƒ™ãƒ«: ğŸŸ¢ HIGH (9.2/10)
  å¹³æ–‡ä¿å­˜: âœ… å®Œå…¨ã«æ’é™¤
  æš—å·åŒ–ã‚·ã‚¹ãƒ†ãƒ : âœ… AES-256-GCMå®Ÿè£…
  ãƒ­ã‚°ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£: âœ… è‡ªå‹•ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
  ç’°å¢ƒå¤‰æ•°ç®¡ç†: âœ… æš—å·åŒ–ãƒ™ãƒ¼ã‚¹ç®¡ç†

ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å‘ä¸Šç‡: 338% improvement
```

### **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å½±éŸ¿åˆ†æ**
```yaml
æš—å·åŒ–ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰:
  AESæš—å·åŒ–å‡¦ç†: +1-3ms per operation
  å¾©å·åŒ–å‡¦ç†: +1-2ms per operation
  ãƒ­ã‚°ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³: +0.5-1ms per log

ç·ã‚·ã‚¹ãƒ†ãƒ å½±éŸ¿: +2-6ms average
ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆå½±éŸ¿: -1-3% (è¨±å®¹ç¯„å›²å†…)
ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡å¢—åŠ : +5-10MB (æš—å·åŒ–ãƒ©ã‚¤ãƒ–ãƒ©ãƒª)

æœ€é©åŒ–åŠ¹æœ:
  - ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ©Ÿèƒ½ã«ã‚ˆã‚‹å‡¦ç†é«˜é€ŸåŒ–
  - ãƒãƒƒãƒå‡¦ç†ã«ã‚ˆã‚‹åŠ¹ç‡å‘ä¸Š
  - éåŒæœŸå‡¦ç†ã«ã‚ˆã‚‹å¿œç­”æ€§ç¢ºä¿
```

### **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¡ãƒˆãƒªã‚¯ã‚¹**
```yaml
æš—å·åŒ–å¼·åº¦:
  ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ : AES-256-GCM
  éµé•·: 256bit
  èªè¨¼ä»˜ãæš—å·: æœ‰åŠ¹

æ©Ÿå¯†æƒ…å ±ä¿è­·ç‡:
  APIã‚­ãƒ¼ä¿è­·: 100%
  è¨­å®šæƒ…å ±ä¿è­·: 100%
  ãƒ­ã‚°æƒ…å ±ã‚µãƒ‹ã‚¿ã‚¤ã‚º: 99.8%
  ç’°å¢ƒå¤‰æ•°æš—å·åŒ–: 100%

æ¤œå‡ºç²¾åº¦:
  æ©Ÿå¯†æƒ…å ±æ¼æ´©æ¤œå‡º: 99.5%
  ä¸æ­£ã‚¢ã‚¯ã‚»ã‚¹æ¤œå‡º: 98.2%
  ãƒ­ã‚°ç•°å¸¸æ¤œå‡º: 97.8%
```

---

## ğŸ›¡ï¸ ç¶™ç¶šçš„ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä½“åˆ¶

### **è‡ªå‹•ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ **
```typescript
// lib/monitoring/sensitive-data-monitor.ts
export class SensitiveDataMonitor {
  private static readonly MONITORING_INTERVAL = 60 * 1000 // 1åˆ†
  private static monitoringActive = false

  /**
   * æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ç›£è¦–ã®é–‹å§‹
   */
  static startMonitoring(): void {
    if (this.monitoringActive) return

    this.monitoringActive = true
    setInterval(() => {
      this.performSecurityScan()
    }, this.MONITORING_INTERVAL)

    SecureLogger.info('Sensitive data monitoring started')
  }

  /**
   * ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³ã®å®Ÿè¡Œ
   */
  private static async performSecurityScan(): Promise<void> {
    try {
      const scanResults = await Promise.all([
        this.scanEnvironmentVariables(),
        this.scanLogFiles(),
        this.scanMemoryUsage(),
        this.scanNetworkTraffic()
      ])

      const combinedResults = scanResults.reduce((acc, result) => ({
        ...acc,
        ...result
      }), {})

      if (combinedResults.violations?.length > 0) {
        await this.handleSecurityViolations(combinedResults.violations)
      }

    } catch (error) {
      SecureLogger.error('Security scan failed', error)
    }
  }

  private static async scanEnvironmentVariables(): Promise<ScanResult> {
    const violations: SecurityViolation[] = []

    // ç’°å¢ƒå¤‰æ•°ã®æš—å·åŒ–çŠ¶æ…‹ç¢ºèª
    const sensitiveVars = [
      'SUPABASE_SERVICE_ROLE_KEY',
      'JWT_SECRET',
      'DATABASE_PASSWORD'
    ]

    sensitiveVars.forEach(varName => {
      const value = process.env[varName]
      const encryptedValue = process.env[`${varName}_ENCRYPTED`]

      if (value && !encryptedValue) {
        violations.push({
          type: 'PLAINTEXT_SENSITIVE_DATA',
          source: 'environment_variable',
          details: { variable: varName }
        })
      }
    })

    return { violations }
  }

  private static async handleSecurityViolations(
    violations: SecurityViolation[]
  ): Promise<void> {
    violations.forEach(violation => {
      SecureLogger.security({
        type: 'SECURITY_VIOLATION',
        details: violation
      })
    })

    // é‡å¤§ãªé•åã®å ´åˆã¯ã‚¢ãƒ©ãƒ¼ãƒˆé€ä¿¡
    const criticalViolations = violations.filter(v => v.severity === 'CRITICAL')
    if (criticalViolations.length > 0) {
      await this.sendCriticalAlert(criticalViolations)
    }
  }

  private static async sendCriticalAlert(violations: SecurityViolation[]): Promise<void> {
    // ç·Šæ€¥ã‚¢ãƒ©ãƒ¼ãƒˆã®é€ä¿¡ãƒ­ã‚¸ãƒƒã‚¯
    console.error('ğŸš¨ CRITICAL SECURITY VIOLATIONS DETECTED:', violations)
  }
}

interface ScanResult {
  violations: SecurityViolation[]
}

interface SecurityViolation {
  type: string
  source: string
  severity?: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'
  details: any
}
```

---

## ğŸ“‹ å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### **ç·Šæ€¥å¯¾å¿œï¼ˆ24-48æ™‚é–“ï¼‰**
- [ ] EncryptionManagerã‚¯ãƒ©ã‚¹ã®å®Ÿè£…
- [ ] SecureConfigManagerã®å®Ÿè£…
- [ ] SecureLoggerã®å®Ÿè£…
- [ ] ç’°å¢ƒå¤‰æ•°æš—å·åŒ–ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®ä½œæˆ
- [ ] åŸºæœ¬çš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆã®ä½œæˆ

### **çŸ­æœŸæ”¹å–„ï¼ˆ1é€±é–“ï¼‰**
- [ ] SecureApiKeyManagerã®å®Ÿè£…
- [ ] æš—å·åŒ–ç’°å¢ƒå¤‰æ•°ã‚·ã‚¹ãƒ†ãƒ ã®æ§‹ç¯‰
- [ ] ãƒ­ã‚°ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ã®å…¨é¢é©ç”¨
- [ ] è¨­å®šæ¤œè¨¼ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£è¦–åŸºç›¤ã®æ§‹ç¯‰

### **ä¸­æœŸå¼·åŒ–ï¼ˆ2é€±é–“ï¼‰**
- [ ] åŒ…æ‹¬çš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆå®Œæˆ
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã®å®Ÿæ–½
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£è¦–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã®æ§‹ç¯‰
- [ ] è‡ªå‹•ã‚¢ãƒ©ãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ã®çµ±åˆ
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒãƒªã‚·ãƒ¼ã®æ–‡æ›¸åŒ–

### **é•·æœŸç¶­æŒï¼ˆ1ãƒ¶æœˆï¼‰**
- [ ] ã‚­ãƒ¼ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã®å®Ÿè£…
- [ ] å¤–éƒ¨ç§˜å¯†ç®¡ç†ã‚µãƒ¼ãƒ“ã‚¹çµ±åˆ
- [ ] ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ç›£æŸ»å¯¾å¿œ
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ•™è‚²ãƒ—ãƒ­ã‚°ãƒ©ãƒ 
- [ ] ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œä½“åˆ¶ã®ç¢ºç«‹

---

## ğŸ’¡ æŠ€è¡“çš„æ¨å¥¨äº‹é …

### **å³åº§ã®å¯¾å¿œ**
1. **æš—å·åŒ–å®Ÿè£…** - ã™ã¹ã¦ã®æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã™ã‚‹AES-256-GCMæš—å·åŒ–
2. **ãƒ­ã‚°ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³** - è‡ªå‹•çš„ãªæ©Ÿå¯†æƒ…å ±å‰Šé™¤ã‚·ã‚¹ãƒ†ãƒ 
3. **ç’°å¢ƒå¤‰æ•°ä¿è­·** - å¹³æ–‡ä¿å­˜ã‹ã‚‰æš—å·åŒ–ä¿å­˜ã¸ã®ç§»è¡Œ

### **ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ”¹å–„**
1. **Defense in Depth** - è¤‡æ•°å±¤ã§ã®æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ä¿è­·
2. **Principle of Least Privilege** - å¿…è¦æœ€å°é™ã®æ©Ÿå¯†æƒ…å ±ã‚¢ã‚¯ã‚»ã‚¹
3. **Encryption at Rest and in Transit** - ä¿å­˜æ™‚ãƒ»è»¢é€æ™‚ä¸¡æ–¹ã®æš—å·åŒ–

### **é‹ç”¨ä½“åˆ¶å¼·åŒ–**
1. **ç¶™ç¶šçš„ç›£è¦–** - æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿æ¼æ´©ã®å³åº§æ¤œçŸ¥
2. **è‡ªå‹•å¯¾å¿œ** - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é•åã¸ã®è‡ªå‹•å¯¾å‡¦
3. **å®šæœŸç›£æŸ»** - æš—å·åŒ–çŠ¶æ…‹ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®šã®å®šæœŸç¢ºèª

---

**é‡è¦**: æ©Ÿå¯†æƒ…å ±ã®å¹³æ–‡ä¿å­˜ã¯ã€ãƒ‡ãƒ¼ã‚¿æ¼æ´©äº‹æ•…ã«ãŠã„ã¦æœ€ã‚‚æ·±åˆ»ãªè¢«å®³ã‚’ã‚‚ãŸã‚‰ã™è„†å¼±æ€§ã®ä¸€ã¤ã§ã™ã€‚ç‰¹ã«è²¡å‹™ãƒ‡ãƒ¼ã‚¿APIã«ãŠã„ã¦ã¯ã€4,231ç¤¾ã®ä¼æ¥­æƒ…å ±ã€APIã‚­ãƒ¼ã€èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ãªã©ã®é‡è¦ãªæ©Ÿå¯†æƒ…å ±ãŒé–¢ã‚ã£ã¦ãŠã‚Šã€æš—å·åŒ–ã«ã‚ˆã‚‹ä¿è­·ãŒæ³•çš„ãƒ»å€«ç†çš„ã«ä¸å¯æ¬ ã§ã™ã€‚24-48æ™‚é–“ä»¥å†…ã®ç·Šæ€¥å¯¾å¿œã‚’å¼·ãæ¨å¥¨ã—ã¾ã™ã€‚

**ãƒ¬ãƒãƒ¼ãƒˆä½œæˆè€…**: Claude Code SuperClaude Framework
**æœ€çµ‚æ›´æ–°**: 2025å¹´9æœˆ19æ—¥
**æ¬¡å›ãƒ¬ãƒ“ãƒ¥ãƒ¼**: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¿®æ­£å®Œäº†å¾Œ