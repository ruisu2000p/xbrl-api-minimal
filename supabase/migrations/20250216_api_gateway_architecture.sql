-- Migration: API Gateway Architecture Foundations
-- Description: Align schema with edge gateway, API key lifecycle, and usage tracking requirements
-- Generated by ChatGPT

-- 1. Core user directory table (mirrors auth.users but allows extension)
CREATE TABLE IF NOT EXISTS public.users (
  id UUID PRIMARY KEY,
  email TEXT,
  name TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

COMMENT ON TABLE public.users IS 'Application user directory (mirrors auth.users.id).';

-- Ensure entries exist for current auth users when table is empty
INSERT INTO public.users (id, email, created_at, updated_at)
SELECT au.id, au.email, au.created_at, au.updated_at
FROM auth.users au
LEFT JOIN public.users u ON u.id = au.id
WHERE u.id IS NULL;

-- 2. Subscription management table
CREATE TABLE IF NOT EXISTS public.subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  plan_type TEXT NOT NULL CHECK (plan_type IN ('free', 'pro', 'enterprise')),
  status TEXT NOT NULL CHECK (status IN ('active', 'canceled', 'expired')),
  started_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ,
  stripe_subscription_id TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_subscriptions_user_id ON public.subscriptions(user_id);
CREATE INDEX IF NOT EXISTS idx_subscriptions_status ON public.subscriptions(status);
CREATE INDEX IF NOT EXISTS idx_subscriptions_plan_status ON public.subscriptions(plan_type, status);

COMMENT ON TABLE public.subscriptions IS 'Stripe-backed subscription states per user.';

-- 3. API key lifecycle enhancements
ALTER TABLE public.api_keys
  ADD COLUMN IF NOT EXISTS key_prefix TEXT,
  ADD COLUMN IF NOT EXISTS key_suffix TEXT,
  ADD COLUMN IF NOT EXISTS masked_key TEXT,
  ADD COLUMN IF NOT EXISTS is_active BOOLEAN DEFAULT true,
  ADD COLUMN IF NOT EXISTS expires_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS rate_limit_per_minute INTEGER DEFAULT 100,
  ADD COLUMN IF NOT EXISTS rate_limit_per_hour INTEGER DEFAULT 10000,
  ADD COLUMN IF NOT EXISTS rate_limit_per_day INTEGER DEFAULT 100000;

-- Align new boolean with legacy status column if present
UPDATE public.api_keys
SET is_active = CASE
  WHEN status IS NULL THEN COALESCE(is_active, true)
  ELSE status = 'active'
END
WHERE is_active IS NULL;

-- Populate suffix/masked columns for existing keys when possible
UPDATE public.api_keys
SET key_suffix = COALESCE(key_suffix, RIGHT(key_hash, 4)),
    masked_key = COALESCE(masked_key, CONCAT(COALESCE(key_prefix, 'key'), '...', RIGHT(key_hash, 4)))
WHERE key_hash IS NOT NULL;

CREATE INDEX IF NOT EXISTS idx_api_keys_prefix ON public.api_keys(key_prefix);
CREATE INDEX IF NOT EXISTS idx_api_keys_active ON public.api_keys(is_active) WHERE is_active = true;

COMMENT ON COLUMN public.api_keys.key_prefix IS 'Human friendly prefix (e.g. fin_live).';
COMMENT ON COLUMN public.api_keys.key_suffix IS 'Display-only suffix (e.g. last 4).';
COMMENT ON COLUMN public.api_keys.masked_key IS 'Masked representation for dashboards.';
COMMENT ON COLUMN public.api_keys.is_active IS 'Soft enable/disable flag for API key.';
COMMENT ON COLUMN public.api_keys.rate_limit_per_minute IS 'Maximum requests allowed per minute.';
COMMENT ON COLUMN public.api_keys.rate_limit_per_day IS 'Maximum requests allowed per day.';

-- 4. API usage ledger
CREATE TABLE IF NOT EXISTS public.api_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  api_key_id UUID NOT NULL REFERENCES public.api_keys(id) ON DELETE CASCADE,
  user_id UUID REFERENCES public.users(id) ON DELETE SET NULL,
  endpoint TEXT,
  status INTEGER,
  cost NUMERIC,
  latency_ms INTEGER,
  used_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_api_usage_api_key ON public.api_usage(api_key_id);
CREATE INDEX IF NOT EXISTS idx_api_usage_used_at ON public.api_usage(used_at DESC);
CREATE INDEX IF NOT EXISTS idx_api_usage_user_id ON public.api_usage(user_id);

COMMENT ON TABLE public.api_usage IS 'Immutable per-request usage and billing ledger.';

-- 5. Rolling usage counters to support rate limiting
CREATE TABLE IF NOT EXISTS public.api_usage_counters_minute (
  api_key_id UUID NOT NULL REFERENCES public.api_keys(id) ON DELETE CASCADE,
  bucket_start TIMESTAMPTZ NOT NULL,
  request_count INTEGER NOT NULL DEFAULT 0,
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (api_key_id, bucket_start)
);

CREATE TABLE IF NOT EXISTS public.api_usage_counters_hour (
  api_key_id UUID NOT NULL REFERENCES public.api_keys(id) ON DELETE CASCADE,
  bucket_hour TIMESTAMPTZ NOT NULL,
  request_count INTEGER NOT NULL DEFAULT 0,
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (api_key_id, bucket_hour)
);

CREATE TABLE IF NOT EXISTS public.api_usage_counters_day (
  api_key_id UUID NOT NULL REFERENCES public.api_keys(id) ON DELETE CASCADE,
  bucket_date DATE NOT NULL,
  request_count INTEGER NOT NULL DEFAULT 0,
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (api_key_id, bucket_date)
);

CREATE INDEX IF NOT EXISTS idx_api_usage_counters_minute_updated ON public.api_usage_counters_minute(updated_at DESC);
CREATE INDEX IF NOT EXISTS idx_api_usage_counters_hour_updated ON public.api_usage_counters_hour(updated_at DESC);
CREATE INDEX IF NOT EXISTS idx_api_usage_counters_day_updated ON public.api_usage_counters_day(updated_at DESC);

-- 6. RPC to increment counters atomically and return current counts
CREATE OR REPLACE FUNCTION public.increment_usage_counters(p_api_key_id UUID)
RETURNS TABLE(minute_count INTEGER, hour_count INTEGER, day_count INTEGER) AS $$
DECLARE
  v_now TIMESTAMPTZ := NOW();
  v_minute_bucket TIMESTAMPTZ := DATE_TRUNC('minute', v_now);
  v_hour_bucket TIMESTAMPTZ := DATE_TRUNC('hour', v_now);
  v_day_bucket DATE := (v_now AT TIME ZONE 'UTC')::DATE;
BEGIN
  INSERT INTO public.api_usage_counters_minute AS m (api_key_id, bucket_start, request_count, updated_at)
  VALUES (p_api_key_id, v_minute_bucket, 1, v_now)
  ON CONFLICT (api_key_id, bucket_start)
  DO UPDATE SET
    request_count = m.request_count + 1,
    updated_at = v_now
  RETURNING m.request_count INTO minute_count;

  INSERT INTO public.api_usage_counters_hour AS h (api_key_id, bucket_hour, request_count, updated_at)
  VALUES (p_api_key_id, v_hour_bucket, 1, v_now)
  ON CONFLICT (api_key_id, bucket_hour)
  DO UPDATE SET
    request_count = h.request_count + 1,
    updated_at = v_now
  RETURNING h.request_count INTO hour_count;

  INSERT INTO public.api_usage_counters_day AS d (api_key_id, bucket_date, request_count, updated_at)
  VALUES (p_api_key_id, v_day_bucket, 1, v_now)
  ON CONFLICT (api_key_id, bucket_date)
  DO UPDATE SET
    request_count = d.request_count + 1,
    updated_at = v_now
  RETURNING d.request_count INTO day_count;

  RETURN NEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION public.increment_usage_counters IS 'Atomically increments per-minute/day counters and returns the latest tallies.';

-- 7. Helpers to keep updated_at in sync
CREATE OR REPLACE FUNCTION public.touch_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS update_subscriptions_updated_at ON public.subscriptions;
CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON public.subscriptions
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

DROP TRIGGER IF EXISTS update_users_updated_at ON public.users;
CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON public.users
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

DROP TRIGGER IF EXISTS update_api_usage_counters_minute ON public.api_usage_counters_minute;
CREATE TRIGGER update_api_usage_counters_minute
BEFORE UPDATE ON public.api_usage_counters_minute
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

DROP TRIGGER IF EXISTS update_api_usage_counters_hour ON public.api_usage_counters_hour;
CREATE TRIGGER update_api_usage_counters_hour
BEFORE UPDATE ON public.api_usage_counters_hour
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

DROP TRIGGER IF EXISTS update_api_usage_counters_day ON public.api_usage_counters_day;
CREATE TRIGGER update_api_usage_counters_day
BEFORE UPDATE ON public.api_usage_counters_day
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();
